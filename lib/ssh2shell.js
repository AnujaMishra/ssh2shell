// Generated by CoffeeScript 1.10.0
(function() {
  var EventEmitter, SSH2Shell,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  EventEmitter = require('events').EventEmitter;

  SSH2Shell = (function(superClass) {
    extend(SSH2Shell, superClass);

    SSH2Shell.prototype.sshObj = {};

    SSH2Shell.prototype.command = "";

    SSH2Shell.prototype._stream = {};

    SSH2Shell.prototype._data = "";

    SSH2Shell.prototype._buffer = "";

    SSH2Shell.prototype._connections = [];

    SSH2Shell.prototype._pipes = [];

    SSH2Shell.prototype.idleTime = 5000;

    SSH2Shell.prototype.asciiFilter = "";

    SSH2Shell.prototype.textColorFilter = "";

    SSH2Shell.prototype.passwordPromt = "";

    SSH2Shell.prototype.passphrasePromt = "";

    SSH2Shell.prototype.standardPromt = "";

    SSH2Shell.prototype.onCommandProcessing = function() {};

    SSH2Shell.prototype.onCommandComplete = function() {};

    SSH2Shell.prototype.onCommandTimeout = function() {};

    SSH2Shell.prototype.onEnd = function() {};

    SSH2Shell.prototype.pipe = function(destination) {
      this._pipes.push(destination);
      return this;
    };

    SSH2Shell.prototype.unpipe = function() {};

    SSH2Shell.prototype._processData = function(data) {
      this._buffer += data;
      if (this.command && this.command.indexOf("sudo ") !== -1) {
        return this._processPasswordPrompt();
      } else if (this.command && this.command.indexOf("ssh ") !== -1) {
        return this._processSSHPrompt();
      } else if (this.standardPromt.test(this._buffer)) {
        if (this.sshObj.debug) {
          this.emit('msg', this.sshObj.server.host + ": Normal prompt detected");
        }
        this.sshObj.pwSent = false;
        return this._processNextCommand();
      } else {
        this.emit('commandProcessing', this.command, this._buffer, this.sshObj, this._stream);
        if (this.sshObj.idleTimer) {
          clearTimeout(this.sshObj.idleTimer);
        }
        return this.sshObj.idleTimer = setTimeout((function(_this) {
          return function() {
            return _this.emit('commandTimeout', _this.command, _this._buffer, _this._stream, _this._connection);
          };
        })(this), this.idleTime);
      }
    };

    SSH2Shell.prototype._processPasswordPrompt = function() {
      if (this.sshObj.verbose) {
        this.emit('msg', this.sshObj.server.host + ": Password prompt: Sent flag " + this.sshObj.pwSent);
      }
      if (!this.sshObj.pwSent) {
        if (this.sshObj.verbose) {
          this.emit('msg', this.sshObj.server.host + ": Password prompt: Buffer: " + this._buffer);
        }
        if (this.passwordPromt.test(this._buffer)) {
          if (this.sshObj.debug) {
            this.emit('msg', this.sshObj.server.host + ": Password prompt: Send password ");
          }
          if (this.sshObj.verbose) {
            this.emit('msg', this.sshObj.server.host + ": Sent password: " + this.sshObj.server.password);
          }
          this.sshObj.pwSent = true;
          return this._stream.write("" + this.sshObj.server.password + this.sshObj.enter);
        } else if (this.standardPromt.test(this._buffer)) {
          if (this.sshObj.debug) {
            this.emit('msg', this.sshObj.server.host + ": Password prompt: Standard prompt after password sent");
          }
          return this._processNextCommand();
        }
      } else if (this.standardPromt.test(this._buffer)) {
        if (this.sshObj.debug) {
          this.emit('msg', this.sshObj.server.host + ": Password prompt: Standard prompt detected");
        }
        return this._processNextCommand();
      } else {
        if (this.passwordPromt.test(this._buffer)) {
          if (this.sshObj.verbose) {
            this.emit('msg', this.sshObj.server.host + ": Sudo password faied: Buffer: " + this._buffer);
          }
          this.emit('error', "Sudo password was incorrect for " + this.sshObj.server.userName + ", leaving host.", "Sudo authentication");
          if (this.sshObj.debug) {
            this.emit('msg', this.sshObj.server.host + ": Failed password prompt: Password: [" + this.sshObj.server.password + "]");
          }
          this.sshObj.sessionText += "" + this._buffer;
          this._buffer = "";
          this.sshObj.commands = [];
          return this._stream.write('\x03');
        }
      }
    };

    SSH2Shell.prototype._processSSHPrompt = function() {
      var password;
      if (!this.sshObj.sshAuth) {
        if (this.passwordPromt.test(this._buffer)) {
          if (this.sshObj.debug) {
            this.emit('msg', this.sshObj.server.host + ": SSH password prompt");
          }
          this.sshObj.sshAuth = true;
          return this._stream.write("" + this.sshObj.server.password + this.sshObj.enter);
        } else if (this.passphrasePromt.test(this._buffer)) {
          if (this.sshObj.debug) {
            this.emit('msg', this.sshObj.server.host + ": SSH passphrase prompt");
          }
          this.sshObj.sshAuth = "true";
          return this._stream.write("" + this.sshObj.server.passPhrase + this.sshObj.enter);
        } else if (this.standardPromt.test(this._buffer)) {
          if (this.sshObj.debug) {
            this.emit('msg', this.sshObj.server.host + ": SSH auth normal prompt");
          }
          this.sshObj.sshAuth = true;
          this.sshObj.sessionText += "Connected to " + this.sshObj.server.host + this.sshObj.enter;
          return this._processNextCommand();
        }
      } else {
        if ((password = this.passwordPromt.test(this._buffer) || this.passphrasePromt.test(this._buffer))) {
          this.sshObj.sshAuth = false;
          this.emit('error', "SSH authentication failed for " + this.sshObj.server.userName + "@" + this.sshObj.server.host, "Nested host authentication");
          if (this.sshObj.debug) {
            this.emit('msg', "Using " + (password ? "password: [" + this.sshObj.server.password + "]" : "passphrase: [" + this.sshObj.server.passPhrase + "]"));
          }
          if (this._connections.length > 0) {
            this.sshObj = this._connections.pop();
          }
          this.sshObj.sessionText += "" + this._buffer;
          return this._stream.write('\x03');
        } else if (this.standardPromt.test(this._buffer)) {
          if (this.sshObj.debug) {
            this.emit('msg', this.sshObj.server.host + ": SSH normal prompt");
          }
          this.sshObj.sessionText += "Connected to " + this.sshObj.server.host + this.sshObj.enter;
          return this._processNextCommand();
        }
      }
    };

    SSH2Shell.prototype._processNotifications = function() {
      var msgNote, results, sessionNote;
      results = [];
      while (this.command && ((sessionNote = this.command.match(/^`(.*)`$/)) || (msgNote = this.command.match(/^msg:(.*)$/)))) {
        if (sessionNote) {
          this.sshObj.sessionText += this.sshObj.server.host + ": Note: " + sessionNote[1] + this.sshObj.enter;
          if (this.sshObj.verbose) {
            this.emit('msg', sessionNote[1]);
          }
        } else if (msgNote) {
          this.emit('msg', this.sshObj.server.host + ": Note: " + msgNote[1]);
        }
        if (this.sshObj.commands.length > 0) {
          results.push(this.command = this.sshObj.commands.shift());
        } else {
          results.push(this._runExit());
        }
      }
      return results;
    };

    SSH2Shell.prototype._processNextCommand = function() {
      if (this.command.indexOf("sudo su") !== -1) {
        this.sshObj.exitCommands.push("exit");
      }
      if (this.command !== "" && this.command !== "exit" && this.command.indexOf("ssh ") === -1) {
        this._buffer = this._buffer.replace(this.asciiFilter, "");
        if (!this.sshObj.disableColorFilter) {
          this._buffer = this._buffer.replace(this.textColorFilter, "");
        }
        this.sshObj.sessionText += this._buffer;
      }
      this.emit('commandComplete', this.command, this._buffer, this.sshObj);
      if (this.sshObj.verbose) {
        this.emit('msg', this.sshObj.server.host + ": Command complete: Response: " + this._buffer);
      }
      this._buffer = "";
      if (this.sshObj.commands.length > 0) {
        this.command = this.sshObj.commands.shift();
        this._processNotifications();
        if (this.command) {
          return this._runCommand();
        } else {
          return this._runExit();
        }
      } else {
        return this._runExit();
      }
    };

    SSH2Shell.prototype._runCommand = function() {
      if (this.sshObj.debug) {
        this.emit('msg', this.sshObj.server.host + ": Next command: " + this.command);
      }
      return this._stream.write("" + this.command + this.sshObj.enter);
    };

    SSH2Shell.prototype._nextHost = function() {
      this._buffer = "";
      this.nextHost = this.sshObj.hosts.shift();
      if (this.sshObj.debug) {
        this.emit('msg', this.sshObj.server.host + ": SSH to " + this.nextHost.server.host);
      }
      this._removeEvents();
      this._connections.push(this.sshObj);
      this.sshObj = this.nextHost;
      this._loadDefaults();
      if (this.sshObj.hosts && this.sshObj.hosts.length === 0) {
        this.sshObj.exitCommands.push("exit");
      }
      this.sshObj.commands.unshift("ssh -oStrictHostKeyChecking=no " + this.sshObj.server.userName + "@" + this.sshObj.server.host);
      return this._processNextCommand();
    };

    SSH2Shell.prototype._runExit = function() {
      var host;
      if (this.sshObj.exitCommands && this.sshObj.exitCommands.length > 0) {
        if (this.sshObj.debug) {
          this.emit('msg', this.sshObj.server.host + ": Queued exit commands: " + this.sshObj.exitCommands);
        }
        this.command = this.sshObj.exitCommands.pop();
        return this._runCommand();
      } else if (this.sshObj.hosts && this.sshObj.hosts.length > 0) {
        if (this.sshObj.debug) {
          this.emit('msg', this.sshObj.server.host + ": Queued hosts for this host");
        }
        if (this.sshObj.debug) {
          this.emit('msg', this.sshObj.hosts);
        }
        return this._nextHost();
      } else if (this._connections && this._connections.length > 0) {
        host = this.sshObj.server.host;
        this.emit('end', this.sshObj.sessionText, this.sshObj);
        if (this.sshObj.idleTimer) {
          clearTimeout(this.sshObj.idleTimer);
        }
        this._removeEvents();
        this.sshObj = this._connections.pop();
        this._loadDefaults();
        if (this.sshObj.debug) {
          this.emit('msg', this.sshObj.enter + "Previous host object:");
        }
        if (this.sshObj.debug) {
          this.emit('msg', this.sshObj);
        }
        if (this.sshObj.debug) {
          this.emit('msg', this.sshObj.server.host + ": Reload previous host object");
        }
        if (this._connections.length > 0) {
          if (this.sshObj.debug) {
            this.emit('msg', this.sshObj.server.host + ": Pushed exit command to disconnect SSH session for " + host);
          }
          this.sshObj.exitCommands.push("exit");
        }
        return this._processNextCommand();
      } else {
        if (this.sshObj.debug) {
          this.emit('msg', this.sshObj.server.host + ": Exit command: Stream: close");
        }
        return this._stream.close();
      }
    };

    SSH2Shell.prototype._removeEvents = function() {
      if (this.sshObj.debug) {
        this.emit('msg', this.sshObj.server.host + ": Clearing previous event handlers");
      }
      this.removeListener('commandProcessing', this.onCommandProcessing);
      this.removeListener('commandComplete', this.onCommandComplete);
      this.removeListener('commandTimeout', this.onCommandTimeout);
      return this.removeListener('end', this.onEnd);
    };

    SSH2Shell.prototype._loadDefaults = function() {
      var ref, ref1, ref2, ref3, ref4, ref5;
      if (!this.sshObj.msg) {
        this.sshObj.msg = {
          send: (function(_this) {
            return function(message) {
              return console.log(message);
            };
          })(this)
        };
      }
      if (!this.sshObj.connectedMessage) {
        this.sshObj.connectedMessage = "Connected";
      }
      if (!this.sshObj.readyMessage) {
        this.sshObj.readyMessage = "Ready";
      }
      if (!this.sshObj.closedMessage) {
        this.sshObj.closedMessage = "Closed";
      }
      if (!this.sshObj.verbose) {
        this.sshObj.verbose = false;
      }
      if (!this.sshObj.debug) {
        this.sshObj.debug = false;
      }
      if (!this.sshObj.hosts) {
        this.sshObj.hosts = [];
      }
      if (!this.sshObj.standardPrompt) {
        this.sshObj.standardPrompt = ">$%#";
      }
      if (!this.sshObj.passwordPromt) {
        this.sshObj.passwordPromt = ":";
      }
      if (!this.sshObj.passphrasePromt) {
        this.sshObj.passphrasePromt = ":";
      }
      if (!this.sshObj.enter) {
        this.sshObj.enter = "\n";
      }
      if (!this.sshObj.asciiFilter) {
        this.sshObj.asciiFilter = "[^\r\n\x20-\x7e]";
      }
      if (!this.sshObj.disableColorFilter) {
        this.sshObj.disableColorFilter = false;
      }
      if (!this.sshObj.textColorFilter) {
        this.sshObj.textColorFilter = "(\[{1}[0-9;]+m{1})";
      }
      if (!this.sshObj.exitCommands) {
        this.sshObj.exitCommands = [];
      }
      if (!this.sshObj.pwSent) {
        this.sshObj.pwSent = false;
      }
      if (!this.sshObj.sshAuth) {
        this.sshObj.sshAuth = false;
      }
      this.sshObj.server.hashKey = (ref = this.sshObj.server.hashKey) != null ? ref : "";
      if (!this.sshObj.sessionText) {
        this.sshObj.sessionText = "";
      }
      this.idleTime = (ref1 = this.sshObj.idleTimeOut) != null ? ref1 : 5000;
      if (!this.asciiFilter) {
        this.asciiFilter = new RegExp(this.sshObj.asciiFilter, "g");
      }
      if (!this.textColorFilter) {
        this.textColorFilter = new RegExp(this.sshObj.textColorFilter, "g");
      }
      if (!this.passwordPromt) {
        this.passwordPromt = new RegExp("password.*" + this.sshObj.passwordPromt + "\\s?$", "i");
      }
      if (!this.passphrasePromt) {
        this.passphrasePromt = new RegExp("password.*" + this.sshObj.passphrasePromt + "\\s?$", "i");
      }
      if (!this.standardPromt) {
        this.standardPromt = new RegExp("[" + this.sshObj.standardPrompt + "]\\s?$");
      }
      this.onCommandProcessing = (ref2 = this.sshObj.onCommandProcessing) != null ? ref2 : (function(_this) {
        return function(command, response, sshObj, stream) {};
      })(this);
      this.onCommandComplete = (ref3 = this.sshObj.onCommandComplete) != null ? ref3 : (function(_this) {
        return function(command, response, sshObj) {
          if (_this.sshObj.debug) {
            return _this.emit('msg', _this.sshObj.server.host + ": Class.commandComplete");
          }
        };
      })(this);
      this.onCommandTimeout = (ref4 = this.sshObj.onCommandTimeout) != null ? ref4 : (function(_this) {
        return function(command, response, stream, connection) {
          if (_this.sshObj.debug) {
            _this.emit('msg', _this.sshObj.server.host + ": Class.commandTimeout");
          }
          if (_this.sshObj.verbose) {
            _this.emit('msg', _this.sshObj.server.host + ": Timeout command: " + command + " response: " + response);
          }
          return _this.emit("error", _this.sshObj.server.host + ": Command timed out after " + (_this.idleTime / 1000) + " seconds", "Timeout", true, function(err, type) {
            return _this.sshObj.sessionText += _this._buffer;
          });
        };
      })(this);
      this.onEnd = (ref5 = this.sshObj.onEnd) != null ? ref5 : (function(_this) {
        return function(sessionText, sshObj) {
          if (_this.sshObj.debug) {
            return _this.emit('msg', _this.sshObj.server.host + ": Class.end");
          }
        };
      })(this);
      this.on("commandProcessing", this.onCommandProcessing);
      this.on("commandComplete", this.onCommandComplete);
      this.on("commandTimeout", this.onCommandTimeout);
      return this.on("end", this.onEnd);
    };

    function SSH2Shell(sshObj1) {
      var ref, ref1, ref2, ref3, ref4;
      this.sshObj = sshObj1;
      this.connect = bind(this.connect, this);
      this._loadDefaults = bind(this._loadDefaults, this);
      this._removeEvents = bind(this._removeEvents, this);
      this._runExit = bind(this._runExit, this);
      this._nextHost = bind(this._nextHost, this);
      this._runCommand = bind(this._runCommand, this);
      this._processNextCommand = bind(this._processNextCommand, this);
      this._processNotifications = bind(this._processNotifications, this);
      this._processSSHPrompt = bind(this._processSSHPrompt, this);
      this._processPasswordPrompt = bind(this._processPasswordPrompt, this);
      this._processData = bind(this._processData, this);
      this.unpipe = bind(this.unpipe, this);
      this.pipe = bind(this.pipe, this);
      this.onEnd = bind(this.onEnd, this);
      this.onCommandTimeout = bind(this.onCommandTimeout, this);
      this.onCommandComplete = bind(this.onCommandComplete, this);
      this.onCommandProcessing = bind(this.onCommandProcessing, this);
      this._loadDefaults();
      this.connection = new require('ssh2')();
      this.on("keyboard-interactive", (function(_this) {
        return function(name, instructions, instructionsLang, prompts, finish) {
          var str;
          if (_this.sshObj.debug) {
            _this.emit('msg', _this.sshObj.server.host + ": Class.keyboard-interactive");
          }
          if (_this.sshObj.debug) {
            _this.emit('msg', _this.sshObj.server.host + ": Keyboard-interactive: finish([response, array]) not called in class event handler.");
          }
          if (_this.sshObj.verbose) {
            _this.emit('msg', "name: " + name);
            _this.emit('msg', "instructions: " + instructions);
            str = JSON.stringify(prompts, null, 4);
            _this.emit('msg', "Prompts object: " + str);
          }
          if (_this.sshObj.onKeyboardInteractive) {
            return _this.sshObj.onKeyboardInteractive(name, instructions, instructionsLang, prompts, finish);
          }
        };
      })(this));
      this.on("msg", (ref = this.sshObj.msg.send) != null ? ref : (function(_this) {
        return function(message) {
          return console.log(message);
        };
      })(this));
      this.on("error", (ref1 = this.sshObj.onError) != null ? ref1 : (function(_this) {
        return function(err, type, close, callback) {
          if (close == null) {
            close = false;
          }
          if (_this.sshObj.debug) {
            _this.emit('msg', _this.sshObj.server.host + ": Class.error");
          }
          if (err instanceof Error) {
            _this.emit('msg', "Error: " + err.message + ", Level: " + err.level);
          } else {
            _this.emit('msg', (type + " error: ") + err);
          }
          if (callback) {
            callback(err, type);
          }
          if (close) {
            return _this.connection.end();
          }
        };
      })(this));
      this.on("pipe", (ref2 = this.sshObj.onPipe) != null ? ref2 : (function(_this) {
        return function(source) {
          if (_this.sshObj.debug) {
            return _this.emit('msg', _this.sshObj.server.host + ": Class.pipe");
          }
        };
      })(this));
      this.on("unpipe", (ref3 = this.sshObj.onUnpipe) != null ? ref3 : (function(_this) {
        return function(source) {
          if (_this.sshObj.debug) {
            return _this.emit('msg', _this.sshObj.server.host + ": Class.unpipe");
          }
        };
      })(this));
      this.on("data", (ref4 = this.sshObj.onData) != null ? ref4 : (function(_this) {
        return function(data) {};
      })(this));
    }

    SSH2Shell.prototype.connect = function(callback) {
      var e, error;
      if (this.sshObj.server && this.sshObj.commands) {
        try {
          this.connection.on("keyboard-interactive", (function(_this) {
            return function(name, instructions, instructionsLang, prompts, finish) {
              if (_this.sshObj.debug) {
                _this.emit('msg', _this.sshObj.server.host + ": Connection.keyboard-interactive");
              }
              return _this.emit("keyboard-interactive", name, instructions, instructionsLang, prompts, finish);
            };
          })(this));
          this.connection.on("connect", (function(_this) {
            return function() {
              if (_this.sshObj.debug) {
                _this.emit('msg', _this.sshObj.server.host + ": Connection.connect");
              }
              return _this.emit('msg', _this.sshObj.connectedMessage);
            };
          })(this));
          this.connection.on("ready", (function(_this) {
            return function() {
              if (_this.sshObj.debug) {
                _this.emit('msg', _this.sshObj.server.host + ": Connection.ready");
              }
              _this.emit('msg', _this.sshObj.readyMessage);
              return _this.connection.shell({
                pty: true
              }, function(err, _stream) {
                var i, len, pipe, ref;
                _this._stream = _stream;
                if (err) {
                  _this.emit('error', err, "Shell", true);
                }
                if (_this.sshObj.debug) {
                  _this.emit('msg', _this.sshObj.server.host + ": Connection.shell");
                }
                _this.sshObj.sessionText = "Connected to " + _this.sshObj.server.host + _this.sshObj.enter;
                _this._stream.setEncoding('utf8');
                ref = _this._pipes;
                for (i = 0, len = ref.length; i < len; i++) {
                  pipe = ref[i];
                  _this._stream.pipe(pipe);
                }
                _this.unpipe = _this._stream.unpipe;
                _this._stream.on("error", function(err) {
                  if (_this.sshObj.debug) {
                    _this.emit('msg', _this.sshObj.server.host + ": Stream.error");
                  }
                  return _this.emit('error', err, "Stream");
                });
                _this._stream.stderr.on('data', function(data) {
                  err = new Error("stderr data: " + data);
                  err.level = "stderr";
                  if (_this.sshObj.debug) {
                    _this.emit('msg', _this.sshObj.server.host + ": Stream.stderr.data");
                  }
                  return _this.emit('error', err, "Stream STDERR");
                });
                _this._stream.on("data", function(data) {
                  var e, error;
                  try {
                    _this._processData(data);
                    return _this.emit("data", data);
                  } catch (error) {
                    e = error;
                    err = new Error(e + " " + e.stack);
                    err.level = "Data handling";
                    return _this.emit('error', err, "Stream.read", true);
                  }
                });
                _this._stream.on("pipe", function(source) {
                  return _this.emit('pipe', source);
                });
                _this._stream.on("unpipe", function(source) {
                  return _this.emit('unpipe', source);
                });
                _this._stream.on("finish", function() {
                  if (_this.sshObj.debug) {
                    _this.emit('msg', _this.sshObj.server.host + ": Stream.finish");
                  }
                  _this.emit('end', _this.sshObj.sessionText, _this.sshObj);
                  if (callback) {
                    return callback(_this.sshObj.sessionText);
                  }
                });
                return _this._stream.on("close", function(code, signal) {
                  if (_this.sshObj.debug) {
                    _this.emit('msg', _this.sshObj.server.host + ": Stream.close");
                  }
                  return _this.connection.end();
                });
              });
            };
          })(this));
          this.connection.on("error", (function(_this) {
            return function(err) {
              if (_this.sshObj.debug) {
                _this.emit('msg', _this.sshObj.server.host + ": Connection.error");
              }
              return _this.emit("error", err, "Connection");
            };
          })(this));
          this.connection.on("close", (function(_this) {
            return function(had_error) {
              if (_this.sshObj.debug) {
                _this.emit('msg', _this.sshObj.server.host + ": Connection.close");
              }
              if (_this.sshObj.idleTimer) {
                clearTimeout(_this.sshObj.idleTimer);
              }
              if (had_error) {
                return _this.emit("error", had_error, "Connection close");
              } else {
                return _this.emit('msg', _this.sshObj.closedMessage);
              }
            };
          })(this));
          this.connection.connect({
            host: this.sshObj.server.host,
            port: this.sshObj.server.port,
            forceIPv4: this.sshObj.server.forceIPv4,
            forceIPv6: this.sshObj.server.forceIPv6,
            hostHash: this.sshObj.server.hashMethod,
            hostVerifier: this.sshObj.server.hostVerifier,
            username: this.sshObj.server.userName,
            password: this.sshObj.server.password,
            agent: this.sshObj.server.agent,
            agentForward: this.sshObj.server.agentForward,
            privateKey: this.sshObj.server.privateKey,
            passphrase: this.sshObj.server.passPhrase,
            localHostname: this.sshObj.server.localHostname,
            localUsername: this.sshObj.server.localUsername,
            tryKeyboard: this.sshObj.server.tryKeyboard,
            keepaliveInterval: this.sshObj.server.keepaliveInterval,
            keepaliveCountMax: this.sshObj.server.keepaliveCountMax,
            readyTimeout: this.sshObj.server.readyTimeout,
            sock: this.sshObj.server.sock,
            strictVendor: this.sshObj.server.strictVendor,
            algorithms: this.sshObj.server.algorithms,
            compress: this.sshObj.server.compress,
            debug: this.sshObj.server.debug
          });
          return this._stream;
        } catch (error) {
          e = error;
          return this.emit('error', e + " " + e.stack, "Connection.connect", true);
        }
      } else {
        return this.emit('error', "Missing connection parameters", "Parameters", false, missingParameters(err, type, close)(function() {
          this.emit('msg', this.sshObj.server);
          return this.emit('msg', this.sshObj.commands);
        }));
      }
    };

    return SSH2Shell;

  })(EventEmitter);

  module.exports = SSH2Shell;

}).call(this);
